#!/usr/bin/perl -w

use strict;


my $dataDir = "$ENV{HOME}/.local/share/tagit";
my $itemDir = "$dataDir/items";
my $dbName = "$dataDir/base.sqlite";


# 1)+tagit tag file1 [file2...] -t tag1[,tag2...]
# 2)+tagit show filename
# 3)+tagit list tag
# 4)+tagit taglist
# 5)+tagit get -t mytag [mytag2...]
#	+tagit get object
# 6)+tagit export mytag
#	+tagit export -t mytag [mytag2...]
# 7) TODO: tagit attach object file1 [file2...]
# 7) TODO: tagit search term
# 8) TODO: add VCS suport
# 9) TODO: add URL handling: retrieve, store & tag page
#10) TODO: object relations. mytag tie object1 object2

use constant SQLITE_ERROR     =>   1;   # SQL error or missing database
use constant SQLITE_INTERNAL  =>   2;   # Internal logic error in SQLite
use constant SQLITE_PERM      =>   3;   # Access permission denied
use constant SQLITE_ABORT     =>   4;   # Callback routine requested an abort
use constant SQLITE_BUSY      =>   5;   # The database file is locked
use constant SQLITE_LOCKED    =>   6;   # A table in the database is locked
use constant SQLITE_NOMEM     =>   7;   # A malloc() failed
use constant SQLITE_READONLY  =>   8;   # Attempt to write a readonly database 
use constant SQLITE_INTERRUPT =>   9;   # Operation terminated by sqlite3_interrupt()
use constant SQLITE_IOERR     =>  10;   # Some kind of disk I/O error occurred 
use constant SQLITE_CORRUPT   =>  11;   # The database disk image is malformed 
use constant SQLITE_NOTFOUND  =>  12;   # NOT USED. Table or record not found 
use constant SQLITE_FULL      =>  13;   # Insertion failed because database is full 
use constant SQLITE_CANTOPEN  =>  14;   # Unable to open the database file 
use constant SQLITE_PROTOCOL  =>  15;   # NOT USED. Database lock protocol error 
use constant SQLITE_EMPTY     =>  16;   # Database is empty 
use constant SQLITE_SCHEMA    =>  17;   # The database schema changed 
use constant SQLITE_TOOBIG    =>  18;   # String or BLOB exceeds size limit 
use constant SQLITE_CONSTRAINT=>  19;   # Abort due to constraint violation 
use constant SQLITE_MISMATCH  =>  20;   # Data type mismatch 
use constant SQLITE_MISUSE    =>  21;   # Library used incorrectly 
use constant SQLITE_NOLFS     =>  22;   # Uses OS features not supported on host 
use constant SQLITE_AUTH      =>  23;   # Authorization denied 
use constant SQLITE_FORMAT    =>  24;   # Auxiliary database format error 
use constant SQLITE_RANGE     =>  25;   # 2nd parameter to sqlite3_bind out of range 
use constant SQLITE_NOTADB    =>  26;   # File opened that is not a database file 
use constant SQLITE_ROW       =>  100;  # sqlite3_step() has another row ready 
use constant SQLITE_DONE      =>  101;  # sqlite3_step() has finished executing 


use constant NOT_FOUND		=>	-1;
use constant ALREADY_EXISTS	=>	-2;
use constant SQL_ERROR		=>	-3;
use constant FS_ERROR		=>	-4;

use DBI;
use Digest::MD5::File qw(file_md5_hex);
use File::Spec;
use File::Copy;
use Getopt::Long;


my $base="dbi:SQLite:dbname=$dbName";
my $dbh = DBI->connect($base,"","",
	{
        PrintError => 0,
	}
);





parseArgs();




sub parseArgs {
	my $cmd;
	my $tag;
	unless (@ARGV) {
		$cmd = 'help';
	}
	else {
		$cmd = $ARGV[0];
		shift @ARGV;
	}
	if ($cmd eq 'tag') {
		my @tags;
		GetOptions('tags=s{1,1000}' => \@tags);
		foreach my $file (@ARGV) {
			#tag file
			unless (-f $file) {
				print STDERR "tagit: Not found or is not palin file: $file\n";
				exit 1;
			}
			tag(File::Spec->rel2abs($file), @tags);
		}
	} elsif ($cmd eq 'show') {
		foreach my $file (@ARGV) {
			show(File::Spec->rel2abs($file));
		}
	} elsif ($cmd eq 'taglist') {
		taglist();
	} elsif ($cmd eq 'list') {
		foreach $tag (@ARGV) {
			cmdList($tag);
		}
	} elsif ($cmd eq 'get') {
		doExtract(\&my_symlink);
	} elsif ($cmd eq 'export') {
		doExtract(\&copy);
	}
}


sub doExtract {
	my $extractFunc = shift;
	my @tags;
	my $objects = {};
	GetOptions('tags=s{1,1000}' => \@tags);
	foreach my $tag (@tags) {
		unless (ref listTagContent($tag, $objects)) {
			print STDERR "Internal Error\n";
			exit(2);
		}
	}
	# TODO: add switch to get files by name or source. Default is md5
	foreach my $object (@ARGV) {
		my $objInfo = getObjectInfo($object);
		if ($objInfo == NOT_FOUND) {
			print STDERR "Object $object not found.\n";
			next;
		} elsif ($objInfo == SQL_ERROR) {
			print STDERR "Internal Error\n";
			exit(2);
		}
		$objects->{$objInfo->{md5}} = $objInfo;
	}
	extractList($objects, $extractFunc);
}



sub my_symlink{
	return symlink $_[0], $_[1];
}


sub extractList{
	# extracts objects given by first arg ot user filesystem using function given by second arg.
	# For example, it can be symlink or copy
	my $objects = shift;
	my $exportFunc = shift;
	while (my ($md5, $objInfo) = each %$objects) {
		my $path = date2dir($objInfo->{date}) . "/$md5";
# TODO: hackish - need to handle URLs
		my (undef, undef, $fName) = File::Spec->splitpath($objInfo->{source});
		my ($name, $ext);
		if ($fName =~ /(.*?[^\\])\.(.*)$/) {
			($name, $ext) = ($1, $2)
		} else {
			($name, $ext) = ($fName, '');
		}
		my $i = 0;
		while (-e $fName) {
			++$i;
			$fName = "$name($i).$ext";
		}
		print STDERR "Cannot create symlink $fName to $path for $objInfo->{title}\n" unless ($exportFunc->($path, $fName));
	}
}


sub cmdList {
	my $tag = shift;
	my $files = listTagContent($tag);
# TODO: decide, if I need to show error 'tag not found', or just show empty tag
	return $files unless (ref $files);
# TODO:	add option to show md5, title or both

	while (my ($md5, $row) = each(%$files)) {
		print "$row->{md5}: $row->{source}\n";
	}
}


sub listTagContent {
	my $tag = shift;
	my $files;
	if (@_) {
		#if we have second arg, it's ref hashe where we must append results
		$files = shift;
	} else {
		$files = {};
	}
	my $row;
	my $sth = $dbh->prepare(
		"SELECT md5, source, date, title, description FROM tags INNER JOIN links ON (tags.tid=links.tid) INNER JOIN objects ON (objects.oid = links.oid) WHERE tags.name=?");
	return SQL_ERROR unless($sth->execute($tag));
	while ($row = $sth->fetchrow_hashref) {
		$files->{$row->{md5}} = $row;
	}
	return $files;
}


sub getObjectInfo {
	my $md5 = shift;
	my $result;
	my $sth = $dbh->prepare("SELECT md5, source, date, title, description FROM objects WHERE md5=?");
	return SQL_ERROR unless ($sth->execute($md5));
	return NOT_FOUND unless ($result = $sth->fetchrow_hashref());
	return $result;
}



sub taglist {
	my $sth = $dbh->prepare("SELECT name FROM tags");
	return SQL_ERROR unless ($sth->execute());
	my $tag;
	while ($tag = $sth->fetchrow_array) {
		print "$tag\n";
	}
}



sub show {
	my $file = shift;
	my $md5 = file_md5_hex($file);
	
	my $sth = $dbh->prepare(
		"SELECT name FROM tags INNER JOIN links ON (tags.tid=links.tid) INNER JOIN objects ON (objects.oid = links.oid) WHERE objects.md5=?");
	return SQL_ERROR unless ($sth->execute($md5));
	print "$md5:";
	my $i = 0;
	while (my $tag = $sth->fetchrow_array) {
		print ',' if ($i++);
		print " $tag";
	}
	print "\n";
}


sub tag {
	my $file = shift;
	my @tags = @_;
	my $oid;

#	create date-named dir
	my $time = time();
	my $dirName = date2dir($time);
	mkdir $dirName;

# split filename to parts
	my ($vol, $path, $fName) = File::Spec->splitpath($file);

#	compute md5
my $md5 = file_md5_hex($file);

return ALREADY_EXISTS unless (findObject($md5) == NOT_FOUND);

#	hardlink file into this dir. If different filesystems - copy
	if (!link $file, "$dirName/$md5") {
	# cannot create hardlink, so we need copy
		my $result = copy $file, "$dirName/$md5";
		#if we cannot copy, abort
		return FS_ERROR unless ($result);
	}
	$dbh->do("BEGIN TRANSACTION");
#	store in db: did	md5	external_filename	add_time
	my $sth = $dbh->prepare("INSERT INTO objects (md5, source, title, date) VALUES (?, ?, ?, ?)");
	unless ($sth->execute($md5, $file, $fName, $time)) {
		$dbh->do("ROLLBACK TRANSACTION");
		return SQL_ERROR;
	}
	$oid = $dbh->func('last_insert_rowid');
	my @tids;
	my $tid;
	foreach my $tag (@tags) {
		$sth = $dbh->prepare("INSERT INTO tags (name) VALUES (?)");
		unless ($sth->execute($tag)) {
			$dbh->do("ROLLBACK TRANSACTION");
			return SQL_ERROR;
		} else {
			$tid = $dbh->func('last_insert_rowid');
		}
		push @tids, $tid;

	}
#	store in db for each new tag: tid	tagname;	did	tid
	
	foreach $tid (@tids) {
		$sth = $dbh->prepare("INSERT INTO links (oid, tid) VALUES (?, ?)");
			unless ($sth->execute($oid, $tid)) {
				$dbh->do("ROLLBACK TRANSACTION");
				return SQL_ERROR;
			}
	}
	$dbh->do("COMMIT TRANSACTION");
	


}


sub saveObject{

}

sub findObject{
	my $md5 = shift;

	my $sth = $dbh->prepare("SELECT oid FROM objects WHERE md5=?");
	unless ($sth->execute($md5)) {
		return SQL_ERROR;
	};
	my $oid;
	unless ($oid = $sth->fetchrow_array()) {
		return NOT_FOUND;
	}
	return $oid;
}

sub date2dir {
	my  $date = shift;
	my @times = localtime($date);
	$times[5] += 1900;
	return "$itemDir/$times[5]-$times[4]-$times[3]";
}