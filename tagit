#!/usr/bin/perl -w

use strict;


my $dataDir = "$ENV{HOME}/.local/share/tagit";
my $itemDir = "$dataDir/items";
my $dbName = "$dataDir/base.sqlite";


# 1) tagit tag file1 [file2...] -t tag1[,tag2...]
# 2) tagit show filename
# 3) tagit show tag
# 4) TODO: tagit search term
# 5) TODO: add VCS suport
# 6) TODO: add URL handling: retrieve, store & tag page

use constant NOT_FOUND		=>	-1;
use constant ALREADY_EXISTS	=>	-2;
use constant SQL_ERROR		=>	-3;
use constant FS_ERROR		=>	-4;

use DBI;
use Digest::MD5::File qw(file_md5_hex);
use File::Spec;
use File::Copy;
use Getopt::Long;


my $base="dbi:SQLite:dbname=$dbName";
my $dbh = DBI->connect($base,"","");





parseArgs();




sub parseArgs{
	my $cmd;
	unless (@ARGV) {
		$cmd = 'help';
	}
	else {
		$cmd = $ARGV[0];
		shift @ARGV;
	}
	if ($cmd eq 'tag') {
		my @tags;
		GetOptions('tags=s{1,1000}' => \@tags);
		foreach my $file (@ARGV) {
			#tag file
			unless (-f $file) {
				print STDERR "tagit: Not found or is not palin file: $file\n";
				exit 1;
			}
			tag(File::Spec->rel2abs($file), @tags);
		}
	} elsif ($cmd eq 'show') {
		foreach my $file (@ARGV) {
			show(File::Spec->rel2abs($file));
		}
	} elsif ($cmd eq 'taglist') {
		taglist();
	}
}




sub taglist {
	my $sth = $dbh->prepare("SELECT name FROM tags");
	return SQL_ERROR unless ($sth->execute());
	while (my $tag = $sth->fetchrow_array) {
		print "$tag\n";
	}
}



sub show {
	my $file = shift;
	my $md5 = file_md5_hex($file);
	
	my $sth = $dbh->prepare(
		"SELECT name FROM tags INNER JOIN links ON (tags.tid=links.tid) INNER JOIN objects ON (objects.oid = links.oid) WHERE objects.md5=?");
	return SQL_ERROR unless ($sth->execute($md5));
	print "$md5:";
	my $i = 0;
	while (my $tag = $sth->fetchrow_array) {
		print ',' if ($i++);
		print " $tag";
	}
	print "\n";
}


sub tag {
	my $file = shift;
	my @tags = @_;
	my $oid;

#	create date-named dir
	my @times = localtime;
	$times[5] += 1900;
	my $dirName = "$itemDir/$times[5]-$times[4]-$times[3]";
	mkdir $dirName;

# split filename to parts
	my ($vol, $path, $fName) = File::Spec->splitpath($file);

#	compute md5
my $md5 = file_md5_hex($file);

return ALREADY_EXISTS unless (findObject($md5) == NOT_FOUND);

#	hardlink file into this dir. If different filesystems - copy
	if (!link $file, "$dirName/$md5") {
	# cannot create hardlink, so we need copy
		my $result = copy $file, "$dirName/$md5";
		#if we cannot copy, abort
		return FS_ERROR unless ($result);
	}
	$dbh->do("BEGIN TRANSACTION");
#	store in db: did	md5	external_filename	add_time
	my $sth = $dbh->prepare("INSERT INTO objects (md5, source, title, date) VALUES (?, ?, ?, ?)");
	my $time = time;
	unless ($sth->execute($md5, $file, $fName, $time)) {
		$dbh->do("ROLLBACK TRANSACTION");
		return SQL_ERROR;
	}
	$oid = $dbh->func('last_insert_rowid');
	my @tids;
	my $tid;
	foreach my $tag (@tags) {
		$sth = $dbh->prepare("INSERT INTO tags (name) VALUES (?)");
		unless ($sth->execute($tag)) {
			$dbh->do("ROLLBACK TRANSACTION");
			return SQL_ERROR;
		} else {
			$tid = $dbh->func('last_insert_rowid');
		}
		push @tids, $tid;

	}
#	store in db for each new tag: tid	tagname;	did	tid
	
	foreach $tid (@tids) {
		$sth = $dbh->prepare("INSERT INTO links (oid, tid) VALUES (?, ?)");
			unless ($sth->execute($oid, $tid)) {
				$dbh->do("ROLLBACK TRANSACTION");
				return SQL_ERROR;
			}
	}
	$dbh->do("COMMIT TRANSACTION");
	


}


sub findObject{
	my $md5 = shift;

	my $sth = $dbh->prepare("SELECT oid FROM objects WHERE md5=?");
	unless ($sth->execute($md5)) {
		return SQL_ERROR;
	};
	my $oid;
	unless ($oid = $sth->fetchrow_array()) {
		return NOT_FOUND;
	}
	return $oid;
}