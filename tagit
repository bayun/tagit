#!/usr/bin/perl -w

use strict;


my $dataDir = "$ENV{HOME}/.local/share/tagit";
my $itemDir = "$dataDir/items";
my $dbName = "$dataDir/base.sqlite";


# 1)+tagit tag file1 [file2...] -t tag1[,tag2...]
# 2)+tagit show filename
# 3)+tagit list tag
# 4)+tagit taglist
# 5)+tagit get -t mytag [mytag2...]
#	+tagit get object
# 6)+tagit export mytag
#	+tagit export -t mytag [mytag2...]
# 7) TODO: tagit attach object file1 [file2...]
# 7) TODO: tagit search term	- must search in CONTENT
# 8) TODO: add VCS suport
# 9) TODO: add URL handling: retrieve, store & tag page
#10) TODO: object relations. mytag tie object1 object2

# TODO:
# where stored object used as argument, use identification by:
#	-h (--hash)		- content hash (default)
#	-n (--name)		- object name
#	-s (--source)	- source path
#	-f (--file)		- file in user filesystem to compute hash and use it
# --name and --source can point to multiple objects. In that case, where possible
# and safe we  will use all. If it is unsafe we will return "Ambiguous argument" and code 10
# unsafe operations with multiple objects can be forced with
#	-F (--force)	- allow unsafe operations
#
# Also we need two behaviors when user tryes to add object that already exists in database.
# defaut variant: message "Object XXX already exists" and return code 11
#	-r (--readd)	- just skip object addition and proceed requested operation
# for `tag' command we can also add
#	-c (--copy)		- always copy content, don't try to create a hardlink


use constant SQLITE_ERROR     =>   1;   # SQL error or missing database
use constant SQLITE_INTERNAL  =>   2;   # Internal logic error in SQLite
use constant SQLITE_PERM      =>   3;   # Access permission denied
use constant SQLITE_ABORT     =>   4;   # Callback routine requested an abort
use constant SQLITE_BUSY      =>   5;   # The database file is locked
use constant SQLITE_LOCKED    =>   6;   # A table in the database is locked
use constant SQLITE_NOMEM     =>   7;   # A malloc() failed
use constant SQLITE_READONLY  =>   8;   # Attempt to write a readonly database 
use constant SQLITE_INTERRUPT =>   9;   # Operation terminated by sqlite3_interrupt()
use constant SQLITE_IOERR     =>  10;   # Some kind of disk I/O error occurred 
use constant SQLITE_CORRUPT   =>  11;   # The database disk image is malformed 
use constant SQLITE_NOTFOUND  =>  12;   # NOT USED. Table or record not found 
use constant SQLITE_FULL      =>  13;   # Insertion failed because database is full 
use constant SQLITE_CANTOPEN  =>  14;   # Unable to open the database file 
use constant SQLITE_PROTOCOL  =>  15;   # NOT USED. Database lock protocol error 
use constant SQLITE_EMPTY     =>  16;   # Database is empty 
use constant SQLITE_SCHEMA    =>  17;   # The database schema changed 
use constant SQLITE_TOOBIG    =>  18;   # String or BLOB exceeds size limit 
use constant SQLITE_CONSTRAINT=>  19;   # Abort due to constraint violation 
use constant SQLITE_MISMATCH  =>  20;   # Data type mismatch 
use constant SQLITE_MISUSE    =>  21;   # Library used incorrectly 
use constant SQLITE_NOLFS     =>  22;   # Uses OS features not supported on host 
use constant SQLITE_AUTH      =>  23;   # Authorization denied 
use constant SQLITE_FORMAT    =>  24;   # Auxiliary database format error 
use constant SQLITE_RANGE     =>  25;   # 2nd parameter to sqlite3_bind out of range 
use constant SQLITE_NOTADB    =>  26;   # File opened that is not a database file 
use constant SQLITE_ROW       =>  100;  # sqlite3_step() has another row ready 
use constant SQLITE_DONE      =>  101;  # sqlite3_step() has finished executing 


use constant NOT_FOUND		=>	-1;
use constant ALREADY_EXISTS	=>	-2;
use constant SQL_ERROR		=>	-3;
use constant FS_ERROR		=>	-4;

use DBI;
use Digest::MD5::File qw(file_md5_hex);
use File::Spec;
use File::Copy;
use Getopt::Long qw (:config auto_abbrev permute no_ignore_case);


my $base="dbi:SQLite:dbname=$dbName";
my $dbh = DBI->connect($base,"","",
	{
        PrintError => 0,
	}
);

my %config = (	tags	=> [], 
				name	=> [],
				source	=> [],
				file	=> [],
				hash	=> [],
				force	=> 0,
				readd	=> 0,
				copy	=> 0,
	);

my %commands = (
	tag		=>{
		objects => 1,
		func	=> \&cmdTag,
		unsafe	=> 1,
		args	=> 'file',
	},
	show	=>{
		objects => 1,
		func	=> \&cmdShow,
		unsafe	=> 0,
		args	=> 'hash',
	},
	list	=>{
		objects => 0,
		func	=> \&cmdList,
		unsafe	=> 0,
		args	=> 'tags',
	},
	taglist	=>{
		objects => 0,
		func	=> \&cmdTaglist,
		unsafe	=> 0,
		args	=> '',
	},
	get		=>{
		objects => 1,
		func	=> \&cmdGet,
		unsafe	=> 0,
		args	=> 'hash',
	},
	export	=>{
		objects => 1,
		func	=> \&cmdExport,
		unsafe	=> 0,
		args	=> 'hash',
	},
	attach	=>{
		objects => 1,
		func	=> \&cmdAttach,
		unsafe	=> 1,
		args	=> 'hash',
	},
);

my $cmd;
GetOptions(
	\%config,
	'hash|h=s@{1,1000}',
	'name|n=s@{1,1000}',
	'source|s=s@{1,1000}',
	'file|f=s@{1,1000}',
	'tags|t=s@{1,1000}',
	'force|F',
	'readd|r',
	'copy|c',
);
if (@ARGV) {
	$cmd = shift;
} else {
	stop("You must give a command", 1);
}
stop("Invalid command", 1) unless exists $commands{$cmd};
if ($commands{$cmd}->{objects}) {
	createObjectList();
}
# add onprocessed arguments into config-defined list: tags, file, hash etc
if (@ARGV) {
	push @{$config{$commands{$cmd}->{args}}}, @ARGV;
}
#commands{$cmd}->func();

use Data::Dumper;

print Dumper(\%config);

sub createObjectList {
	
}

#parseArgs();




sub parseArgs {
	my $cmd;
	my $tag;
	unless (@ARGV) {
		$cmd = 'help';
	}
	else {
		$cmd = $ARGV[0];
		shift @ARGV;
	}
	if ($cmd eq 'tag') {
		my @tags;
		GetOptions('tags=s{1,1000}' => \@tags);
		foreach my $file (@ARGV) {
			#tag file
			unless (-f $file) {
				print STDERR "tagit: Not found or is not palin file: $file\n";
				exit 1;
			}
			cmdTag(File::Spec->rel2abs($file), @tags);
		}
	} elsif ($cmd eq 'show') {
		foreach my $file (@ARGV) {
			cmdShow(File::Spec->rel2abs($file));
		}
	} elsif ($cmd eq 'taglist') {
		cmdTaglist();
	} elsif ($cmd eq 'list') {
		foreach $tag (@ARGV) {
			cmdList($tag);
		}
	} elsif ($cmd eq 'get') {
		doExtract(\&my_symlink);
	} elsif ($cmd eq 'export') {
		doExtract(\&copy);
	}
}


sub doExtract {
	my $extractFunc = shift;
	my @tags;
	my $objects = {};
	GetOptions('tags=s{1,1000}' => \@tags);
	foreach my $tag (@tags) {
		unless (ref listTagContent($tag, $objects)) {
			print STDERR "Internal Error\n";
			exit(2);
		}
	}
	# TODO: add switch to get files by name or source. Default is hash
	foreach my $object (@ARGV) {
		my $objInfo = getObjectInfo($object);
		if ($objInfo == NOT_FOUND) {
			print STDERR "Object $object not found.\n";
			next;
		} elsif ($objInfo == SQL_ERROR) {
			print STDERR "Internal Error\n";
			exit(2);
		}
		$objects->{$objInfo->{hash}} = $objInfo;
	}
	extractList($objects, $extractFunc);
}



sub my_symlink{
	return symlink $_[0], $_[1];
}


sub extractList{
	# extracts objects given by first arg ot user filesystem using function given by second arg.
	# For example, it can be symlink or copy
	my $objects = shift;
	my $exportFunc = shift;
	while (my ($hash, $objInfo) = each %$objects) {
		my $path = addtime2dir($objInfo->{addtime}) . "/$hash";
# TODO: hackish - need to handle URLs
		my (undef, undef, $fName) = File::Spec->splitpath($objInfo->{source});
		my ($name, $ext);
		if ($fName =~ /(.*?[^\\])\.(.*)$/) {
			($name, $ext) = ($1, $2)
		} else {
			($name, $ext) = ($fName, '');
		}
		my $i = 0;
		while (-e $fName) {
			++$i;
			$fName = "$name($i).$ext";
		}
		print STDERR "Cannot create symlink $fName to $path for $objInfo->{title}\n" unless ($exportFunc->($path, $fName));
	}
}


sub cmdList {
	my $tag = shift;
	my $files = listTagContent($tag);
# TODO: decide, if I need to show error 'tag not found', or just show empty tag
	return $files unless (ref $files);
# TODO:	add option to show md5, title or both

	while (my ($hash, $row) = each(%$files)) {
		print "$row->{hash}: $row->{source}\n";
	}
}

sub listTagContent {
	my $tag = shift;
	my $files;
	if (@_) {
		#if we have second arg, it's ref hashe where we must append results
		$files = shift;
	} else {
		$files = {};
	}
	my $row;
	my $sth = $dbh->prepare(
		"SELECT hash, source, addtime, title, description FROM tags INNER JOIN links ON (tags.tid=links.tid) INNER JOIN objects ON (objects.oid = links.oid) WHERE tags.name=?");
	return SQL_ERROR unless($sth->execute($tag));
	while ($row = $sth->fetchrow_hashref) {
		$files->{$row->{hash}} = $row;
	}
	return $files;
}


sub getObjectInfo {
	my $hash = shift;
	my $result;
	my $sth = $dbh->prepare("SELECT hash, source, addtime, title, description FROM objects WHERE hash=?");
	return SQL_ERROR unless ($sth->execute($hash));
	return NOT_FOUND unless ($result = $sth->fetchrow_hashref());
	return $result;
}



sub cmdTaglist {
	my $sth = $dbh->prepare("SELECT name FROM tags");
	return SQL_ERROR unless ($sth->execute());
	my $tag;
	while ($tag = $sth->fetchrow_array) {
		print "$tag\n";
	}
}



sub cmdShow {
	my $file = shift;
	my $hash = file_md5_hex($file);
	
	my $sth = $dbh->prepare(
		"SELECT name FROM tags INNER JOIN links ON (tags.tid=links.tid) INNER JOIN objects ON (objects.oid = links.oid) WHERE objects.hash=?");
	return SQL_ERROR unless ($sth->execute($hash));
	print "$hash:";
	my $i = 0;
	while (my $tag = $sth->fetchrow_array) {
		print ',' if ($i++);
		print " $tag";
	}
	print "\n";
}


sub cmdTag {
	my $file = shift;
	my @tags = @_;
	my $oid;

#	create addtime-named dir
	my $time = time();
	my $dirName = addtime2dir($time);
	mkdir $dirName;

# split filename to parts
	my ($vol, $path, $fName) = File::Spec->splitpath($file);

#	compute hash
my $hash = file_md5_hex($file);

return ALREADY_EXISTS unless (findObject($hash) == NOT_FOUND);

#	hardlink file into this dir. If different filesystems - copy
	if (!link $file, "$dirName/$hash") {
	# cannot create hardlink, so we need copy
		my $result = copy $file, "$dirName/$hash";
		#if we cannot copy, abort
		return FS_ERROR unless ($result);
	}
	$dbh->do("BEGIN TRANSACTION");
#	store in db: did	hash	external_filename	add_time
	my $sth = $dbh->prepare("INSERT INTO objects (hash, source, title, addtime) VALUES (?, ?, ?, ?)");
	unless ($sth->execute($hash, $file, $fName, $time)) {
		$dbh->do("ROLLBACK TRANSACTION");
		return SQL_ERROR;
	}
	$oid = $dbh->func('last_insert_rowid');
	my @tids;
	my $tid;
	foreach my $tag (@tags) {
		$sth = $dbh->prepare("INSERT INTO tags (name) VALUES (?)");
		unless ($sth->execute($tag)) {
			$dbh->do("ROLLBACK TRANSACTION");
			return SQL_ERROR;
		} else {
			$tid = $dbh->func('last_insert_rowid');
		}
		push @tids, $tid;

	}
#	store in db for each new tag: tid	tagname;	did	tid
	
	foreach $tid (@tids) {
		$sth = $dbh->prepare("INSERT INTO links (oid, tid) VALUES (?, ?)");
			unless ($sth->execute($oid, $tid)) {
				$dbh->do("ROLLBACK TRANSACTION");
				return SQL_ERROR;
			}
	}
	$dbh->do("COMMIT TRANSACTION");
	


}


sub saveObject{

}

sub findObject{
	# value to search
	my $hash = shift;
	# field to search - reasonable variants are: hash, title, source, addtime
	my $field = shift;
	my $sth = $dbh->prepare("SELECT oid FROM objects WHERE hash=?");
	unless ($sth->execute($hash)) {
		return SQL_ERROR;
	};
	my $oid;
	unless ($oid = $sth->fetchrow_array()) {
		return NOT_FOUND;
	}
	return $oid;
}

sub addtime2dir {
	my  $addtime = shift;
	my @times = localtime($addtime);
	$times[5] += 1900;
	return "$itemDir/$times[5]-$times[4]-$times[3]";
};

sub stop {
	my $code;
	if (scalar @_ >1) {
		$code = pop;
	} else {
		$code = 1;
	}
	print @_, "\n";
	exit $code;
}
