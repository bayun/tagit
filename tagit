#!/usr/bin/perl -w

use strict;


my $dataDir = "$ENV{HOME}/.local/share/tagit";
my $itemDir = "$dataDir/items";
my $dbName = "$dataDir/base.sqlite";


# 1)+tagit tag file1 [file2...] -t tag1[,tag2...]
# 2)+tagit show filename
# 3)+tagit list tag
# 4)+tagit taglist
# 5)+tagit get -t mytag [mytag2...]
#	+tagit get object
# 6)+tagit export mytag
#	+tagit export -t mytag [mytag2...]
# 7) TODO: tagit attach object file1 [file2...]
# 7) TODO: tagit search term	- must search in CONTENT
# 8) TODO: add VCS suport
# 9) TODO: add URL handling: retrieve, store & tag page
#10) TODO: object relations. mytag tie object1 object2

#:
# where stored object used as argument, use identification by:
#	-h (--hash)		- content hash (default)
#	-n (--name)		- object name
#	-s (--source)	- source path
#	-f (--file)		- file in user filesystem to compute hash and use it
# --name and --source can point to multiple objects. In that case, where possible
# and safe we  will use all. If it is unsafe we will return "Ambiguous argument" and code 10
# unsafe operations with multiple objects can be forced with
#	-F (--force)	- allow unsafe operations
#
# Also we have two behaviors when user tryes to add object that already exists in database.
# defaut variant: message "Object XXX already exists" and return code 11
#	-i (--ignore)	- just skip object addition and proceed requested operation
# for `tag' command we can also add
#	-c (--copy)		- always copy content, don't try to create a hardlink


use constant SQLITE_ERROR     =>   1;   # SQL error or missing database
use constant SQLITE_INTERNAL  =>   2;   # Internal logic error in SQLite
use constant SQLITE_PERM      =>   3;   # Access permission denied
use constant SQLITE_ABORT     =>   4;   # Callback routine requested an abort
use constant SQLITE_BUSY      =>   5;   # The database file is locked
use constant SQLITE_LOCKED    =>   6;   # A table in the database is locked
use constant SQLITE_NOMEM     =>   7;   # A malloc() failed
use constant SQLITE_READONLY  =>   8;   # Attempt to write a readonly database 
use constant SQLITE_INTERRUPT =>   9;   # Operation terminated by sqlite3_interrupt()
use constant SQLITE_IOERR     =>  10;   # Some kind of disk I/O error occurred 
use constant SQLITE_CORRUPT   =>  11;   # The database disk image is malformed 
use constant SQLITE_NOTFOUND  =>  12;   # NOT USED. Table or record not found 
use constant SQLITE_FULL      =>  13;   # Insertion failed because database is full 
use constant SQLITE_CANTOPEN  =>  14;   # Unable to open the database file 
use constant SQLITE_PROTOCOL  =>  15;   # NOT USED. Database lock protocol error 
use constant SQLITE_EMPTY     =>  16;   # Database is empty 
use constant SQLITE_SCHEMA    =>  17;   # The database schema changed 
use constant SQLITE_TOOBIG    =>  18;   # String or BLOB exceeds size limit 
use constant SQLITE_CONSTRAINT=>  19;   # Abort due to constraint violation 
use constant SQLITE_MISMATCH  =>  20;   # Data type mismatch 
use constant SQLITE_MISUSE    =>  21;   # Library used incorrectly 
use constant SQLITE_NOLFS     =>  22;   # Uses OS features not supported on host 
use constant SQLITE_AUTH      =>  23;   # Authorization denied 
use constant SQLITE_FORMAT    =>  24;   # Auxiliary database format error 
use constant SQLITE_RANGE     =>  25;   # 2nd parameter to sqlite3_bind out of range 
use constant SQLITE_NOTADB    =>  26;   # File opened that is not a database file 
use constant SQLITE_ROW       =>  100;  # sqlite3_step() has another row ready 
use constant SQLITE_DONE      =>  101;  # sqlite3_step() has finished executing 


use constant NOT_FOUND		=>	-1;
use constant ALREADY_EXISTS	=>	-2;
use constant SQL_ERROR		=>	-3;
use constant FS_ERROR		=>	-4;

use DBI;
use Digest::MD5::File qw(file_md5_hex);
use File::Spec;
use File::Copy;
use Getopt::Long qw (:config auto_abbrev permute no_ignore_case);


my $base="dbi:SQLite:dbname=$dbName";
my $dbh = DBI->connect($base,"","",
	{
        PrintError => 0,
	}
);

my %config = (	tags	=> [], 
				name	=> [],
				source	=> [],
				file	=> [],
				hash	=> [],
				force	=> 0,
				copy	=> 0,
				ignore	=> 0,
	);

my %commands = (
	tag		=>{
		objects => 1,
		func	=> \&cmdTag,
		unsafe	=> 1,
		args	=> 'file',
	},
	show	=>{
		objects => 1,
		func	=> \&cmdShow,
		unsafe	=> 0,
		args	=> 'hash',
	},
	list	=>{
		objects => 0,
		func	=> \&cmdList,
		unsafe	=> 0,
		args	=> 'tags',
	},
	taglist	=>{
		objects => 0,
		func	=> \&cmdTaglist,
		unsafe	=> 0,
		args	=> '',
	},
	get		=>{
		objects => 1,
		func	=> \&cmdGet,
		unsafe	=> 0,
		args	=> 'hash',
	},
	export	=>{
		objects => 1,
		func	=> \&cmdExport,
		unsafe	=> 0,
		args	=> 'hash',
	},
	attach	=>{
		objects => 1,
		func	=> \&cmdAttach,
		unsafe	=> 1,
		args	=> 'hash',
	},
);

my $cmd;
my $objectList;
GetOptions(
	\%config,
	'hash|h=s@{1,1000}',
	'name|n=s@{1,1000}',
	'source|s=s@{1,1000}',
	'file|f=s@{1,1000}',
	'tags|t=s@{1,1000}',
	'force|F',
	'copy|c',
	'ignore|i',
);
if (@ARGV) {
	$cmd = shift;
} else {
	stop("You must give a command", 1);
}
stop("Invalid command", 1) unless exists $commands{$cmd};
# add unprocessed arguments into config-defined list: tags, file, hash etc
if (@ARGV) {
	push @{$config{$commands{$cmd}->{args}}}, @ARGV;
}
if ($commands{$cmd}->{objects}) {
	$objectList = createObjectList();
}

$commands{$cmd}->{func}();

sub createObjectList {
	my $objectList = {};
	my $arr;
	# we have 2 modes for 'file':
	#	1) if we ADD files (unsafe=1), these files must NOT be in database (but we can ignore existence if
	#		--ignore key specified).
	#	2) if we QUERY database, we use fles as source for hash computation and add them to hash array. If
	#		such hash is absend in database, hash handling code returns error or jus continue, depending of
	#		--ignore switch presense
	foreach my $fName (@{$config{file}}) {
		unless (-f $fName) {
			next if ($config{ignore});
			stop("File not found: $fName", 2);
		}
		my $hash = file_md5_hex($fName);
		my $row = findObjects('hash', $hash);
		if ($commands{$cmd}->{unsafe}) {
			if ($row != NOT_FOUND) {
				if ($config{ignore}) {
					push @{$config{hash}}, $hash;
				} else {
					stop("File $fName already exists in database. Use --ignore switch to process command with it", 2);
				}
			} else {
				$config{files_checked}->{$fName} = $hash;
			}
		} else {
			if ($row == NOT_FOUND) {
				stop("File $fName was not found in database. You need to add it first using 'add' or 'attach' commands", 2);
			}
			push @{$config{hash}}, $hash;
		}
	}

	foreach my $hash (@{$config{hash}}) {
		$arr = findObjects('hash', $hash, $objectList);
		if ($arr == SQL_ERROR) {
			return SQL_ERROR;
		}
		stop("There is no such object: $hash", 2) if ($arr == NOT_FOUND && !$config{ignore});
	}
	foreach my $type(('hash', 'name', 'source')) {
		foreach my $value (@{$config{$type}}) {
			$arr = findObjects($type, $value, $objectList);
			if ($arr == SQL_ERROR) {
				return SQL_ERROR;
			}
			stop("There is no such object: $value", 2) if ($arr == NOT_FOUND && !$config{ignore});
		}
	}
	return $objectList;
}


sub getTagsObjects {
	# ref to array of tag names
	my $tags = shift;
	# ref to destination array - optional
	my $objects;
	$objects = shift if (@_);
	my $results = {};
	foreach my $tag(@$tags) {
		my $tagContent = listTagContent($tag, $results);
		stop("Internal Error", 2) if ($tagContent == SQL_ERROR);
	}
	hashMerge($objects, $results) if $objects;
	return $results;
}

sub cmdGet {
	map {extractList($_, \&my_symlink)} ($objectList, getTagsObjects($config{tags}));
}

sub cmdExport {
	map {extractList($_, \&copy)} ($objectList, getTagsObjects($config{tags}));
}

sub my_symlink{
	return symlink $_[0], $_[1];
}

sub extractList{
	# extracts objects given by first arg ot user filesystem using function given by second arg.
	# For example, it can be symlink or copy
	my $objects = shift;
	my $exportFunc = shift;
	while (my ($hash, $objInfo) = each %$objects) {
		my $path = hash2dir($objInfo->{hash}) . "/$hash";
		# TODO: hackish - need to handle URLs
		my (undef, undef, $fName) = File::Spec->splitpath($objInfo->{source});
		my ($name, $ext);
		if ($fName =~ /(.*?[^\\])\.(.*)$/) {
			($name, $ext) = ($1, $2)
		} else {
			($name, $ext) = ($fName, '');
		}
		my $i = 0;
		while (-e $fName) {
			++$i;
			$fName = "$name($i).$ext";
		}
		print STDERR "Cannot create symlink $fName to $path for $objInfo->{name}\n" unless ($exportFunc->($path, $fName));
	}
}


sub cmdList {
	my $files = getTagsObjects($config{tags});
# TODO: decide, if I need to show error 'tag not found', or just show empty tag
	return $files unless (ref $files);
# TODO:	add option to change output format
	while (my ($hash, $row) = each(%$files)) {
		print "$row->{hash}: $row->{source}\n";
	}
}

sub listTagContent {
	my $tag = shift;
	my $objects;
	if (@_) {
		#if we have second arg, it's ref to hash where we must append results
		$objects = shift;
	} else {
		$objects = {};
	}
	my $result = {};
	my $row;
	my $sth = $dbh->prepare(
		"SELECT * FROM tags INNER JOIN links ON (tags.tid=links.tid) INNER JOIN objects ON (objects.oid = links.oid) WHERE tags.name=?");
	return SQL_ERROR unless($sth->execute($tag));
	while ($row = $sth->fetchrow_hashref) {
		$result->{$row->{hash}} = $row;
	}
	return NOT_FOUND unless (%$result);
	hashMerge($objects, $result) if ($objects);
	return $result;
}


sub hashMerge {
	return undef unless @_;
	my $main = shift;
	foreach my $hash (@_) {
		while (my ($k, $v) = each(%$hash)) {
			$main->{$k} = $v;
		}
	}
	
	return $main;
}

sub getObjectInfo {
	my $hash = shift;
	my $result;
	my $sth = $dbh->prepare("SELECT hash, source, addtime, name, description FROM objects WHERE hash=?");
	return SQL_ERROR unless ($sth->execute($hash));
	return NOT_FOUND unless ($result = $sth->fetchrow_hashref());
	return $result;
}



sub cmdTaglist {
	my $sth = $dbh->prepare("SELECT name FROM tags");
	return SQL_ERROR unless ($sth->execute());
	my $tag;
	while ($tag = $sth->fetchrow_array) {
		print "$tag\n";
	}
}

sub getObjectTags {
	# accepts hash that identify object;
	# returns ref to list with tag names
	my $hash = shift;
	my @tags;
	my $sth = $dbh->prepare(
		"SELECT tags.name FROM tags INNER JOIN links ON (tags.tid=links.tid) INNER JOIN objects ON (objects.oid = links.oid) WHERE objects.hash=?");
	return SQL_ERROR unless ($sth->execute($hash));
	while (my $tagName = $sth->fetchrow_array) {
		push @tags, $tagName;
	}
	return \@tags;
}
sub cmdShow {
# TODO: add different output formats
	while (my ($hash, $row) = each(%$objectList)) {
		my $tags = getObjectTags($hash);
		print "$hash:";
		my $i = 0;
		foreach my $tag (@$tags) {
			print ',' if ($i++);
			print " $tag";
		}
		print "\n";
	}
}


sub grabObject {
	my ($file, $hash) = @_;
#TODO: refactor to accept URLs
#	create date-named dir
	my $time = time();
	my $dirName = hash2dir($hash);
	mkdir $dirName;

	# split filename to parts
	my ($vol, $path, $fName) = File::Spec->splitpath($file);

	# hardlink file into this dir. If not allowed (by --copy) or different filesystems - copy
	if ($config{copy} || !link $file, "$dirName/$hash") {
	# cannot create hardlink, so we need copy
		my $result = copy $file, "$dirName/$hash";
		#if we cannot copy, abort
		return FS_ERROR unless ($result);
	}
	#	store in db: did	hash	external_filename	add_time
	$file = File::Spec->rel2abs($file);
	my $sth = $dbh->prepare("INSERT INTO objects (hash, source, name, addtime) VALUES (?, ?, ?, ?)");
	unless ($sth->execute($hash, $file, $fName, $time)) {
		return SQL_ERROR;
	}
	my $oid = $dbh->func('last_insert_rowid');
}

sub cmdTag {
	unless (scalar @{$config{tags}}) {
		stop("Please, enter at least one tag (after --tags switch) to tag with", 1);
	}
	my @oids;
	my $oid;
	$dbh->do("BEGIN TRANSACTION");
	while(my ($file, $hash) = each %{$config{files_checked}}) {
		$oid = grabObject($file, $hash);
		unless ($oid > 0) {
			$dbh->do("ROLLBACK TRANSACTION");
			stop("Error while importing $file", 3);
		}
		push @oids, $oid;
	}
	my @tids;
	my $tid;
	my $sth = $dbh->prepare("INSERT INTO tags (name) VALUES (?)");
	foreach my $tag (@{$config{tags}}) {
		unless ($sth->execute($tag)) {
			$dbh->do("ROLLBACK TRANSACTION");
			stop("Error while adding tag $tag", 3);
		} else {
			$tid = $dbh->func('last_insert_rowid');
		}
		push @tids, $tid;

	}
#	store in db for each new tag: tid	tagname;	did	tid
	$sth = $dbh->prepare("INSERT INTO links (oid, tid) VALUES (?, ?)");
	foreach my $oid(@oids) {
		foreach $tid (@tids) {
			unless ($sth->execute($oid, $tid)) {
				$dbh->do("ROLLBACK TRANSACTION");
				stop("Error while tagging object", 3);
			}
		}
	}
	$dbh->do("COMMIT TRANSACTION");
}

sub findObjects{
	# field to search - reasonable variants are: oid, hash, name. Possible also source, addtime and description, 
	# but these fields are not indexed
	my $field = shift;
	# value to search
	my $value = shift;
	# ref to hash to add result (optional)
	# returns ref to hash: $hash => $row
	my $objects;
	if (@_) {
		$objects = shift;
	}
	my %results;
	my $sth = $dbh->prepare("SELECT * FROM objects WHERE $field=?");
	unless ($sth->execute($value)) {
		return SQL_ERROR;
	};
	my $row;
	while ($row = $sth->fetchrow_hashref()) {
		$results{$row->{hash}} = $row;
	}
	return NOT_FOUND if (!%results);
	hashMerge $objects, \%results if ($objects);
	return \%results;
}

sub hash2dir {
	my  $hash = shift;
	my $prefix = substr $hash, 0, 2;
	return "$itemDir/$prefix";
};

sub stop {
	my $code;
	if (scalar @_ >1) {
		$code = pop;
	} else {
		$code = 1;
	}
	print @_, "\n";
	exit $code;
}
